/* eslint-disable max-len */
import chaiHttp from 'chai-http';
import nock from 'nock';
import sinon from 'sinon';
import sinonChai from 'sinon-chai';
import chai, {
  expect,
  should,
} from 'chai';

import models from '../../server/models';
import app from '../../server/index';
import authMock from '../mocks/authMock';
import generatePassword from '../../server/helpers/auth/generatePassword';
import GoogleStrategy
from '../../server/controllers/auth/strategies/googleStrategy';
import socialMediaControllerCallback from
'../../server/controllers/auth/socialMediaControllerCallback';
import TwitterStrategy
from '../../server/controllers/auth/strategies/twitterStrategy';

const {User} = models;
chai.use(chaiHttp);

should();
chai.use(sinonChai);

describe('Passwords are autogenerated',()=>{
  it('should generate a valid hashed password', () => {
    expect(generatePassword()).to.be.a('string');
    expect(generatePassword().length).to.be.at.least(30);
    expect(generatePassword()).to.not.be.undefined;
  });
});

describe('Users can login through /api/v1/auth/google', () => {
  before(async () => {
    await nock('https://accounts.google.com')
      .filteringPath(() => '/')
      .get('/')
      .reply(200, authMock().profile);
  });

  it('should return 200 if user is successfully', async () => {
    const res = await chai.request(app).get('/api/v1/auth/google');
    expect(res).to.have.status(200);
    expect(res.body.id).to.equal('4b2a1e1d-7e9f-406a-b22a-950a101d7675');
    expect(res.body.name.givenName).to.be.a('string');
    expect(res.body.name.familyName).to.be.a('string');
    expect(res.body.emails[0].value).to.be.a('string');
  });
});
describe('Google passport Strategy functions', () => {
  context('Google Strategy Methods', () => {
    it('should be a method', () => {
      expect(GoogleStrategy.googleStrategy).to.be.a('function');
    });
    it('should exist GoogleStrategy function', () => {
      expect(GoogleStrategy.googleStrategy).to.exist;
    });
    it('should exist googleStrategyCallback function', () => {
      expect(GoogleStrategy.googleStrategyCallback).to.exist;
    });
    it('should be a method googleStrategyCallback', () => {
      expect(GoogleStrategy.googleStrategyCallback).to.be.a('function');
    });

  });


});

describe('Google passport authentication',() => {
  context('Users should be registered if they are new',()=>{
    const {user} = authMock();
    const req = {
      user,
      headers:{
        host: 'localhost:3000'
      }
    };
    const res = {
      status() {
        return this;
      },
      json(obj) {
        return obj;
      }
    };
    expect(socialMediaControllerCallback.socialMediaControllerCallback(req, res).message)
    .to.equal('Registration Successfull');
  });

  context('Users should be logged in if they have an account already',()=>{
    const {oldUser} = authMock();
    const req = {
      user: oldUser,
      headers:{
        host: 'localhost:3000'
      }
    };
    const res = {
      status() {
        return this;
      },
      json(obj) {
        return obj;
      }
    };
    expect(socialMediaControllerCallback.socialMediaControllerCallback(req, res).message)
    .to.equal('Login Successfull');
  });

  context('Save a new user authenticated by Google', async () => {
    before(() => {
      sinon.spy(User, 'findOrCreate');
    });

    after(() => {
      User.findOrCreate.restore();
    });

    const done = sinon.stub();
    const {profile} = authMock();
    const {accessToken, refreshToken} = authMock().tokens;
    await GoogleStrategy
    .googleStrategyCallback(accessToken, refreshToken, profile, done);
    User.findOrCreate.called;
  });
});

describe('Twitter passport authentication',() => {
  context('Save a new user authenticated by Twitter', async () => {
    before(() => {
      sinon.spy(User, 'findOrCreate');
    });

    after(() => {
      User.findOrCreate.restore();
    });
    const done = sinon.stub();
    const {twitterProfile} = authMock();
    const {accessToken, refreshToken} = authMock().tokens;
    await TwitterStrategy
    .twitterStrategyCallback(accessToken, refreshToken, twitterProfile, done);
    User.findOrCreate.called;
  });
});
